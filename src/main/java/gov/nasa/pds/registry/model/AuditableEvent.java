//	Copyright 2009-2010, by the California Institute of Technology.
//	ALL RIGHTS RESERVED. United States Government Sponsorship acknowledged.
//	Any commercial use must be negotiated with the Office of Technology 
//	Transfer at the California Institute of Technology.
//	
//	This software is subject to U. S. export control laws and regulations 
//	(22 C.F.R. 120-130 and 15 C.F.R. 730-774). To the extent that the software 
//	is subject to U.S. export control laws and regulations, the recipient has 
//	the responsibility to obtain export licenses or other export authority as 
//	may be required before exporting such information to foreign countries or 
//	providing access to foreign nationals.
//	
//	$Id$
//

package gov.nasa.pds.registry.model;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.JoinColumn;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

/**
 * AuditableEvent instances provide a long-term record of events that effected a
 * change in a RegistryObject. A RegistryObject is associated with an ordered
 * Set of AuditableEvent instances that provide a complete audit trail for that
 * RegistryObject. AuditableEvents are usually a result of a client-initiated
 * request. AuditableEvent instances are generated by the Registry Service to
 * log such Events. Often such events effect a change in the life cycle of a
 * RegistryObject. For example a client request could Create, Update, Deprecate
 * or Delete a RegistryObject. An AuditableEvent is typically created when a
 * request creates or alters the content or ownership of a RegistryObject.
 * Read-only requests typically do not generate an AuditableEvent.
 * 
 * @author pramirez
 * 
 */
@Entity
@XmlRootElement(name = "auditableEvent", namespace = "http://registry.pds.nasa.gov")
@XmlType(name = "")
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditableEvent extends RegistryObject {

  private static final long serialVersionUID = -1091556687686639668L;

  /**
   * Each AuditableEvent MUST have an eventType attribute which identifies the
   * type of event recorded by the AuditableEvent.
   */
  @XmlAttribute
  private EventType eventType;

  /**
   * Each AuditableEvent MUST have an affectedObjects attribute that identifies
   * the Set of RegistryObjects instances that were affected by this event.
   */
  @ElementCollection
  @CollectionTable(name = "Affected_Objects", joinColumns = @JoinColumn(name = "event_id"))
  @Column(name = "affected_object")
  @XmlElement(name = "affectedObject", namespace = "http://registry.pds.nasa.gov")
  private List<String> affectedObjects;

  /**
   * Each AuditableEvent MUST have a requestId attribute that identifies the
   * client request instance that affected this event.
   */
  @XmlAttribute
  private String requestId;

  /**
   * Each AuditableEvent MUST have a timestamp attribute that records the date
   * and time that this event occurred.
   */
  @XmlAttribute
  @Temporal(TemporalType.TIMESTAMP)
  private Date timestamp;

  /**
   * Each AuditableEvent MUST have a user attribute that identifies the User
   * that sent the request that generated this event affecting the
   * RegistryObject instance.
   */
  @XmlAttribute
  @Column(name = "userid")
  private String user;

  public AuditableEvent() {
     this.setObjectType(AuditableEvent.class.getSimpleName());
     this.timestamp = new Date();
     this.affectedObjects = new ArrayList<String>();
  }

  public AuditableEvent(EventType eventType, List<String> affectedObjects,
      String user) {
    this();
    this.eventType = eventType;
    this.affectedObjects = affectedObjects;
    this.user = user;
  }

  /**
   * @return the eventType
   */
  public EventType getEventType() {
    return eventType;
  }

  /**
   * @param eventType
   *          the eventType to set
   */
  public void setEventType(EventType eventType) {
    this.eventType = eventType;
  }

  /**
   * @return the guid of the registry object this event is associated with
   */
  public List<String> getAffectedObjects() {
    return affectedObjects;
  }

  /**
   * @param affectedObjects
   *          the guid of the registry object this event is associated with
   */
  public void setAffectedObjects(List<String> affectedObjects) {
    this.affectedObjects = affectedObjects;
  }

  /**
   * @return the timestamp when the event occurred
   */
  public Date getTimestamp() {
    return timestamp;
  }

  /**
   * @param timestamp
   *          the timestamp to when event occured
   */
  public void setTimestamp(Date timestamp) {
    this.timestamp = timestamp;
  }

  /**
   * @return identifier that maps to a user
   */
  public String getUser() {
    return user;
  }

  /**
   * @param user
   *          an unique user id to set
   */
  public void setUser(String user) {
    this.user = user;
  }

  /**
   * @return identifies the request made to cause this event
   */
  public String getRequestId() {
    return requestId;
  }

  /**
   * @param requestId
   *          unique id for request that generated this event
   */
  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result
        + ((affectedObjects == null) ? 0 : affectedObjects.hashCode());
    result = prime * result + ((eventType == null) ? 0 : eventType.hashCode());
    result = prime * result + ((requestId == null) ? 0 : requestId.hashCode());
    result = prime * result + ((timestamp == null) ? 0 : timestamp.hashCode());
    result = prime * result + ((user == null) ? 0 : user.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (!super.equals(obj))
      return false;
    if (getClass() != obj.getClass())
      return false;
    AuditableEvent other = (AuditableEvent) obj;
    if (affectedObjects == null) {
      if (other.affectedObjects != null)
        return false;
    } else if (!affectedObjects.equals(other.affectedObjects))
      return false;
    if (eventType == null) {
      if (other.eventType != null)
        return false;
    } else if (!eventType.equals(other.eventType))
      return false;
    if (requestId == null) {
      if (other.requestId != null)
        return false;
    } else if (!requestId.equals(other.requestId))
      return false;
    if (timestamp == null) {
      if (other.timestamp != null)
        return false;
    } else if (!timestamp.equals(other.timestamp))
      return false;
    if (user == null) {
      if (other.user != null)
        return false;
    } else if (!user.equals(other.user))
      return false;
    return true;
  }

}
